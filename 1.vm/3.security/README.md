# x86-64 Memory Security — From Boot to Runtime

---

## 0) Блоки безопасности (высокоуровневый обзор)

**Режимы и привилегии**

* **Rings**: ring0 (kernel) … ring3 (user). Текущий уровень — **CPL** из CS.
* **DPL/RPL**: дескрипторная модель (сегменты/гейты) задаёт **DPL**; эффективный уровень доступа учитывает **CPL** и **RPL** селектора.

**Пейджинг/Права**

* **PTE флаги**: `P, R/W, U/S, NX, A, D, G, PAT...` управляют наличием, записью, доступом user/supervisor и исполнением.
* **CR0.WP**: write‑protect в supervisor — запрещает ядру писать в read‑only страницы.
* **EFER.NXE**: включает бит NX (DEP/W^X).
* **CR4.PCIDE**: включает PCID (контексты TLB по процессам).

**Доп. механизмы**

* **SMEP (CR4.SMEP)**: запрет исполнения кода ядром из страниц user (`U=1`).
* **SMAP (CR4.SMAP)**: запрет доступа ядра к user‑страницам без явного разрешения (флаг AC в RFLAGS).
* **PKU/PKE (CR4.PKE)**: per‑page **Protection Keys** + регистр **PKRU** для user‑mode избирательного запрета R/W.
* **CET (shadow stack/CFG)**: аппаратная защита возвратов/потоков управления (новые CPU).
* **KPTI/PTI**: изоляция таблиц страниц user/kernel для смягчения Meltdown.

---

## 1) Старт: от прошивки до Long Mode (с акцентом на безопасность)

1. **Reset → Firmware (BIOS/UEFI)**

* Переход в загрузчик, выбор ядра.

2. **Bootloader**

* Готовит **GDT** (минимум: code/data для kernel, TSS), включает protected mode.
* Включает **PAE** (CR4.PAE=1), настраивает первичные **page tables**, записывает **CR3**.
* Включает **Long Mode**: `EFER.LME=1`, затем `CR0.PG=1` → **LMA** активен.
* Готовит **IDT** (вектора прерываний/исключений), **TSS/IST** (стэки для критичных векторов).

3. **Kernel early init**

* Включает **EFER.NXE=1** (DEP), **CR0.WP=1** (RO защита в supervisor).
* Опционально включает **CR4.SMEP/SMAP/PKE/UMIP**.
* Строит финальные **page tables**: раздельные области **user** и **kernel** (см. §2), применяет **W^X**:

    * `.text` ядра: **RX** (read+exec).
    * `.rodata`: **RO**.
    * данные/кучи: **RW**, **NX**.
    * стек(и): **RW**, **NX**, + **guard pages** (not‑present).
* Включает **KASLR** (рандомизация размещения ядра/карт).
* Настраивает путь системных вызовов (**SYSCALL/SYSRET**: MSR STAR/LSTAR/SFMASK) и/или **int 0x80**.
* При необходимости включает **KPTI**: отдельные CR3 для user/kernel, минимальный "trampoline" в user‑таблицах.

---

## 2) Разделение адресного пространства (User vs Kernel)

```
48‑бит VA (примерная схема)

+---------------------------------------------------------------+
|                         Kernel space                          |
|                 FFFF_8000_0000_0000 .. FFFF_FFFF_FFFF_FFFF    |
|   U/S=0, RX/RO/RW по секциям, NX для данных, global mappings  |
+---------------------------------------------------------------+
|                          User space                           |
|                 0000_0000_0000_0000 .. 0000_7FFF_FFFF_FFFF    |
|   U/S=1, W^X: code RX, data RW+NX, guard pages, ASLR          |
+---------------------------------------------------------------+
```

* Ядро обычно отображено одинаково во всех процессах (global), если не используется KPTI.
* User‑страницы помечены `U=1`, Kernel — `U=0`.

---

## 3) PTE флаги и политики разметки

**Упрощённая карта PTE (x86‑64):**

```
PTE: [ PPN ............................................. | NX | G | D | A | PCD | PWT | U/S | R/W | P ]
```

* **P** (Present): 1 — страница в RAM; 0 — not‑present (swap/не выделено/guard).
* **R/W**: 0 — только чтение; 1 — запись разрешена.
* **U/S**: 1 — доступен user‑mode; 0 — только supervisor.
* **PWT/PCD/PAT**: политика кэширования/тип памяти.
* **A/D**: пометки «доступалась/модифицировалась» (CPU или ядро).
* **G**: global (переживает смену CR3 без флеша, если разрешено).
* **NX**: запрет исполнения (работает, если EFER.NXE=1).

**Политики (best‑practice):**

* **W^X**: ни одна страница не одновременно writable и executable.
* **Kernel text**: RX, `U=0`.
* **Kernel rodata**: RO, `U=0`, NX.
* **Kernel data/heap/stack**: RW, `U=0`, NX, guard pages.
* **User code**: RX, `U=1`.
* **User data/heap/stack**: RW, `U=1`, NX, guard pages.

---

## 4) Проверка доступа: где и как она происходит

**Пайплайн доступа**

1. Трансляция VA→PA через TLB или page‑walk.
2. Вместе с PPN подтягиваются **атрибуты доступа** (U/S, R/W, NX, PAT...).
3. CPU сверяет:

    * **Привилегии**: `U/S` vs **CPL** (ring). Если `U=0` и CPL=3 → запрет.
    * **Тип доступа**: чтение/запись/исполнение vs `R/W` и `NX`.
    * **Доп. политики**:

        * **SMEP**: в CPL<3 запрещает **исполнение** из страниц `U=1`.
        * **SMAP**: в CPL<3 запрещает **чтение/запись** в `U=1`, если `AC=0`.
        * **PKU**: в CPL=3 проверяет ключ страницы против **PKRU** (R/W‑маски).
4. При нарушении генерирует **#PF (page fault)** с кодом ошибки.

**Код ошибки #PF (суть):**

* `P` (1 = protection violation, 0 = not‑present).
* `W/R` (1 = запись, 0 = чтение).
* `U/S` (1 = fault в CPL=3, 0 = в supervisor).
* `I/D` (1 = fetch инструкции; NX/SMEP кейсы).
* `PK` (1 = нарушение PKU, если поддерживается).
* `RSVD` (1 = зарезервированные биты в PTE нарушены).

**Примеры:**

* **CPL=3 пишет в RO страницу (`R/W=0`)** → `P=1, W/R=1, U/S=1`.
* **Ядро (CPL=0) выполняет код на user‑странице при SMEP=1** → `P=1, I/D=1, U/S=0` (защита SMEP).
* **Ядро читает user‑страницу при SMAP=1 и `AC=0`** → protection fault (supervisor), пока ядро не поднимет `AC` локально.

---

## 5) Переходы привилегий и безопасность путей

**Системные вызовы**

* Путь **SYSCALL**: CPU берёт RIP из `MSR_LSTAR`, CPL→0, маскирует флаги по `MSR_SFMASK`, ядро делает `SWAPGS`, переходит на kernel stack/entry.
* **SYSRET** возвращает в user (особые требования к RIP/FLAGS).
* Исторический путь `int 0x80`: IDT‑гейт с **DPL=3** разрешает вызов из user; много накладных расходов, но DPL управляет доступом.

**Прерывания/исключения**

* **IDT entry** имеет тип (interrupt/trap), селекторы и **DPL**. Переход в CPL=0 по вектору с настроенным **IST** использует отдельный надёжный стек.
* Критично: корректно задать DPL у пользовательски‑доступных векторов (обычно только системный вызов/брейкпойнт имеют DPL=3).

---

## 6) KPTI, PCID и TLB‑консистентность

**KPTI/PTI**

* В user‑режиме CR3 указывает на **урезанную таблицу**: kernel‑пространство практически не отображено, есть только минимальный trampoline для входа в ядро. Снижает риск утечки через Meltdown.

**PCID**

* Снижает издержки переключения CR3: разные PCID для user/kernel и для разных процессов.

**Invalidate**

* При изменении прав/видимости PTE: `INVLPG` (по адресу), `MOV CR3` (сброс TLB), `INVPCID` (по PCID/адресу), **shootdown** через IPI на SMP.

---

## 7) Пример: как ядро временно читает user‑буфер при SMAP

```
; CPL=0, SMAP=1, нужно скопировать N байт из user_ptr (U=1)

stac                  ; AC=1, разрешить доступ к U=1 из supervisor
rep movsb             ; копирование
clac                  ; AC=0, вновь запретить доступ по SMAP
```

(Аналогичные макросы `uaccess_begin/end` в Linux.)

---

## 8) Дополнительно: контроль целостности

* **CR0.WP=1**: даже ядро не может писать в read‑only, пока не снимет защиту (временное изменение CR0 опасно; лучше remap через PTE и invalidate).
* **RO‑mapping критичных структур** (GDT/IDT/TSS после инициализации) и страницы кода — защита от случайной модификации.
* **CET shadow stacks/IBT** (если доступны) — защита возвратов/непрямых переходов.

---

## 9) TL;DR

* Безопасность памяти на x86‑64 строится вокруг **PTE‑флагов**, **привилегий (CPL/DPL/RPL)** и расширений **CR0/CR4/EFER**.
* На старте ядро включает **NX/DEP**, **WP**, **SMEP/SMAP/PKU** и аккуратно размечает память (**W^X**, user vs kernel, guard pages).
* Проверка прав происходит **на каждом доступе** (через TLB/page‑walk). Нарушения → **#PF** с детализированным кодом.
* Для производительности и изоляции используются **PCID**, **KPTI**, селективные **TLB invalidate**.
