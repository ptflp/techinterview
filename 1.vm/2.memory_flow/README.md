# Address Translation Deep Dive: from VA to PA (all cases)


---

## 0) Мини‑словарь сущностей

* **VA (Virtual Address)** — виртуальный адрес.
* **PA (Physical Address)** — физический адрес.
* **VPN / Offset** — номер виртуальной страницы и смещение внутри страницы.
* **PPN** — номер физической страницы.
* **TLB** — кэш трансляций VA→PA.
* **PT (Page Tables)** — таблицы страниц (PML4→PDPT→PD→PT на x86‑64).
* **PTE** — запись таблицы страниц (ссылается на PPN + флаги).
* **CR3** — регистр с корнем и параметрами адресации.
* **PCID (Process‑Context ID)** — идентификатор контекста для TLB (аналог ASID на ARM).
* **#PF (Page Fault)** — исключение «ошибка страницы».

---

## 1) Формат виртуального адреса и уровни таблиц

На x86‑64 при 4‑КиБ страницах (по умолчанию) 48‑битный VA разбирается так:

```
[ 9 | 9 | 9 | 9 | 12 ] bits
  PML4  PDPT  PD   PT   Offset
```

* Каждый из четырёх по 9 бит индексирует соответствующую таблицу.
* `Offset` адресует байт внутри 4‑КиБ страницы.
* Альтернативы: **2‑МиБ** (huge) страница (пропускает уровень PT), **1‑ГиБ** страница (пропускает PD и PT).

---

## 2) Быстрый путь: TLB lookup

Каждый память‑доступ (инструкции/данные) стартует с запроса в TLB.

```
           VA + PCID
               |
               v
+-------------------------------+
|             TLB               |
|  tag = (VPN, PCID) → PPN, RWX |
+-------------------------------+
       |                |
     HIT              MISS
```

* **PCID** включён, если выставлен `CR4.PCIDE`. Тогда часть TLB может переживать context switch без тотальной очистки.
* В TLB хранятся атрибуты доступа (R/W/X, U/S) и иногда кэш‑атрибуты (PAT/WT/WC/…) — зависит от µархитектуры.

**Case A — TLB Hit**

* Формируется `PA = PPN || Offset`.
* Идёт запрос в кэш L1/L2/L3/память. Никаких таблиц страниц не читается.
* Проверки прав доступа выполняются по атрибутам в TLB; при нарушении возможен **protection fault** даже на hit (см. §6).

---

## 3) Медленный путь: Page Table Walk (TLB Miss)

При промахе TLB вступает в игру «page walker» (аппаратный на x86‑64):

```
CR3 → PML4 → PDPT → PD → PT → PTE
```

* **CR3** содержит физический адрес корня (PML4). На системах с PCID младшие биты CR3 — это PCID, остальное — база PML4.
* Каждая запись верхних уровней — это «page directory entry», указывающий на следующий уровень **или** на огромную страницу (бит PS — Page Size).
* **Где живут таблицы?** В обычной физической памяти (RAM). OS выделяет им физические страницы и заполняет PTE/PMD.
* Процессор может кешировать результаты прохода в «paging‑structure caches» (кеши ходов по таблицам) помимо TLB.

**Case B — PTE найден и `P=1` (present)**

* Контроль флагов (R/W, U/S, NX, …). Если всё ок → формируется `PPN`, затем `PA` и запись может быть закинута в TLB.

**Case C — PTE найден, но защита нарушена**

* `P=1`, но, например, попытка записи при `R/W=0` или доступ из ring3 при `U/S=0`, или исп. код при `NX=1` → **protection fault** (#PF с кодом «present»).

**Case D — PTE отсутствует `P=0`**

* Возникает **not‑present page fault** (#PF с `P=0`). Дальше ситуацию решает ядро (см. §5–§6).

---

## 4) Структура PTE и флаги (x86‑64, упрощённо)

```
63                                  12 11 .. 0
+-------------------------------------+--------+
|           PPN (physical frame)      | flags  |
+-------------------------------------+--------+
```

Ключевые биты (расположение зависит от уровня/формата):

* **P** (Present) — страница присутствует в RAM.
* **R/W** — запись разрешена.
* **U/S** — доступ из user‑mode разрешён.
* **PWT/PCD** — кэш‑политика (write‑through / cache‑disable).
* **A** (Accessed) — страница была обращена (CPU выставляет).
* **D** (Dirty) — была запись (для PTE уровней, где применимо).
* **PAT** — выбор memory‑type через PAT/MTRR.
* **G** (Global) — не очищать на смене CR3 (если не flush глобал).
* **PS** (Page Size) — указывает huge page на уровне PD/PT.
* **NX (XD)** — запрет исполнения (в MSR EFER должен быть NXE).

OS может «перегружать» часть флагов/PPN для кодирования **swap entries** (когда страница выгружена) — тогда `P=0`, но в PTE зашит «куда на диске положили».

---

## 5) Page Fault: типы и ветки обработки

На x86‑64 #PF даёт **error code**. Важные биты:

| Бит  | Значение                                    |
| ---- | ------------------------------------------- |
| P    | 1 = protection violation, 0 = not present   |
| W/R  | 1 = запись, 0 = чтение                      |
| U/S  | 1 = user‑mode, 0 = supervisor               |
| RSVD | 1 = зарезервированный бит в PTE установлен  |
| I/D  | 1 = fetch инструкции (NX/SMEP/PKU сценарии) |
| PK   | 1 = нарушение защиты PKU                    |
| SS   | 1 = shadow stack violation (CET)            |

**Not‑present fault (P=0):**

* Анонимная память: возможно «ленивая» аллокация → ядро выделяет физическую страницу, заполняет нулями (demand‑zero), правит PTE, возвращает в user‑mode.
* File‑backed (mmap): подгружает страницу из page cache/диска.
* Swapped‑out: читает из swap, размещает в RAM, обновляет PTE.

**Protection fault (P=1):**

* Попытка записи в COW‑страницу → ядро выделяет новую страницу, копирует данные, меняет PTE на «writable» (только для текущего процесса), возвращает.
* Запрет доступа по правам (U/S, R/W, NX, SMEP/SMAP/PKU) → обычно SIGSEGV.

---

## 6) Где физически находятся таблицы страниц

* В обычной **RAM**; OS ведёт пул «page frames» для таблиц.
* Верхние уровни указывают на физические адреса следующих уровней.
* Обновления PTE требуют **синхронизации с TLB**: после изменения видимости/прав — выполнить **TLB invalidate** (см. §8).

---

## 7) Большие страницы (Huge Pages)

* **2 MiB** (бит PS в **PD**): пропускается уровень PT; формат PTE на уровне PD содержит PPN большой страницы.
* **1 GiB** (бит PS в **PDPT**): пропускаются PD и PT.
* Плюсы: меньше TLB‑промахов, меньше page‑walk. Минусы: фрагментация, сложности с NUMA/изоляцией.
* Linux: **THP (Transparent Huge Pages)** может автоматически сливать/делить.

---

## 8) Контекст, PCID и управление TLB

**Context switch**:

* Без PCID: смена `CR3` → как правило, TLB flush (или пометка устаревших), кроме global‑entry.
* С PCID (`CR4.PCIDE=1`): в `CR3` кодируется **PCID**; CPU может держать записи разных процессов и переключаться почти без flush. Требуются дисциплина и **INVPCID**/селективные invalidate при изменении PTE.

**Инвалидация TLB**:

* `INVLPG [addr]` — сброс одной строки по VA (+PCID контекст).
* Смена CR3 — сброс (кроме global, если не выключены глобалы).
* **TLB shootdown**: ядро рассылает IPI всем ядрам для консистентного invalidate (важно на SMP).
* `INVPCID` — гибкие режимы инвалидации (по PCID, по адресу и т.д.).

**Global pages** (`PGE`/бит G): переживают смену CR3; удобно для постоянных kernel‑map, но требует глобального сброса при изменении.

---

## 9) Кэш‑иерархия vs TLB

* TLB кэширует **адресные трансляции**, L1/L2/L3 — **данные/инструкции**.
* Возможен TLB‑hit при одновременном cache‑miss (и наоборот).
* Также есть **paging‑structure caches** (кеши самих таблиц страниц), уменьшающие стоимость page walk.

---

## 10) NUMA и размещение физической памяти

* PPN указывает на **frame** в одной из NUMA‑нод; OS/аллокатор решают, где выделять.
* Политики (first‑touch, interleave, migrate) влияют на латентность доступа.

---

## 11) Полный поток (объединённая диаграмма)

```
User/Kernel code issues memory access @ VA
         |
         v
   [VA, Access type (R/W/X), CPL, PCID]
         |
         v
        TLB lookup
     /             \
  HIT               MISS
   |                  |
   v                  v
Form PA         Page Table Walk (CR3 → PML4 → PDPT → PD → PT)
   |                  |
   |              Fetch PTE
   |                  |
   |           P=1 ?  |  P=0
   |               |         \
   |           Check perms     Not‑present #PF
   |           (U/S,R/W,NX,…)      |
   |               |               +-> anon: alloc zero page
   |           OK?  |              +-> file: read page cache/disk
   |            |    |             +-> swap: read from swap
   |            |    +-- violate → protection #PF
   |            v
   |        Cache PTE/insert into TLB
   v
PA = PPN || Offset  → D‑cache/I‑cache → Memory
```

---

## 12) Практические примечания

* **A/D биты**: если CPU не выставляет их аппаратно (некоторые режимы/виртуализация), OS эмитирует soft‑fault для их обновления.
* **COW**: один из самых частых «легитимных» protection faults; ядро «ремапит» на приватную страницу при записи.
* **Guard pages / stack growth**: преднамеренно not‑present PTE для детекта выхода за пределы.
* **PAT/MTRR**: определяют memory‑type (WB/WT/WC/…); корректные настройки критичны для MMIO/PCIe.
* **Kernel vs User**: единое VA‑пространство на x86‑64 обычно разделено (нижние биты — user, верхние — kernel), с U/S контролем.
* **Виртуализация**: EPT/NPT добавляют второй уровень трансляции (GVA→GPA→HPA), что удорожает miss и invalidate.

---

## 13) TL;DR

1. Путь быстрый: **TLB hit → PA → кэши/память**.
2. Путь медленный: **TLB miss → page walk → PTE → (OK | protection fault | not‑present fault)**.
3. Таблицы страниц — обычные физические страницы в RAM, управляются ОС.
4. Консистентность обеспечивается **INVLPG/INVPCID/CR3+shootdown**.
5. Эффективность повышают **PCID**, **huge pages**, аккуратная политика размещения и минимизация invalidate.
